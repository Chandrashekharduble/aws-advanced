AWSTemplateFormatVersion: '2010-09-09'
Description: AWS Fargate Service in private subnet, but accessible via a public load balancer.
Parameters:

  EnvironmentName:
        Description: An environment name that will be prefixed to resource names
        Type: String
        Default: fargate-example

  StackName:
    Type: String
    Default: fargate-service
    Description: The name of the parent Fargate networking stack that you created. Necessary
                 to locate and reference resources created by that stack.

  ClusterName:
    Type: String
    Description: A name of the cluster

  ServiceName:
    Type: String
    Default: SpringBoot
    Description: A name for the service
  ImageUrl:
    Type: String
    Default: 016973021151.dkr.ecr.us-west-1.amazonaws.com/ecs-example-repository:spring-boot
    Description: The url of a docker image 
    
  ContainerPort:
    Type: Number
    Default: 8080
    Description: What port number the application inside the docker container is binding to
  ContainerCpu:
    Type: Number
    Default: 512
    Description: How much CPU to give the container. 1024 is 1 CPU
  ContainerMemory:
    Type: Number
    Default: 1024
    Description: How much memory in megabytes to give the container
  Path:
    Type: String
    Default: "*"
    Description: A path on the public load balancer that this service
                 should be connected to. Use * to send all load balancer
                 traffic to this service.
  HealthCheckPath:
    Type: String
    Default: "/spring-docker/hello"
    Description: path for the LB healthcheck
  Priority:
    Type: Number
    Default: 1
    Description: The priority for the routing rule added to the load balancer.
                 This only applies if your have multiple services which have been
                 assigned to different paths on the load balancer.
  DesiredCount:
    Type: Number
    Default: 1
    Description: How many copies of the service task to run
      
  MaxCount:
    Description: Maximum number of instances of this task we can run across our cluster
    Type: Number
    Default: 3

  Role:
    Type: String
    Default: ""
    Description: (Optional) An IAM role to give the service's containers if the code within needs to
                 access other AWS resources like S3 buckets, DynamoDB tables, etc

Conditions:
  HasCustomRole: !Not [ !Equals [!Ref 'Role', ''] ]

Resources:

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'ServiceName'
      Cpu: !Ref 'ContainerCpu'
      Memory: !Ref 'ContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'ECSTaskExecutionRole']]
         #!Sub '${EnvironmentName}:ECSTaskExecutionRole'
      TaskRoleArn:
        Fn::If:
          - 'HasCustomRole'
          - !Ref 'Role'
          - !Ref "AWS::NoValue"
      ContainerDefinitions:
        - Name: !Ref 'ServiceName'
          Cpu: !Ref 'ContainerCpu'
          Memory: !Ref 'ContainerMemory'
          Image: !Ref 'ImageUrl'
          PortMappings:
            - ContainerPort: !Ref 'ContainerPort'

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  Service:
    Type: AWS::ECS::Service
    DependsOn: LoadBalancerRule
    Properties:
      ServiceName: !Ref 'ServiceName'
      Cluster: 
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'ClusterName']]
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 75
      DesiredCount: !Ref 'DesiredCount'
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - Fn::ImportValue:
                !Join [':', [!Ref 'EnvironmentName', 'FargateContainerSecurityGroup']]           
          Subnets:
            - Fn::ImportValue:
                !Join [':', [!Ref 'EnvironmentName', 'PrivateSubnetOne']]
            - Fn::ImportValue:
                !Join [':', [!Ref 'EnvironmentName', 'PrivateSubnetTwo']]
      TaskDefinition: !Ref 'TaskDefinition'
      LoadBalancers:
        - ContainerName: !Ref 'ServiceName'
          ContainerPort: !Ref 'ContainerPort'
          TargetGroupArn: !Ref 'TargetGroup'


  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: !Ref HealthCheckPath
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      TargetType: ip
      Name: !Ref 'ServiceName'
      Port: !Ref 'ContainerPort'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'VPCId']]
          #!Join ['-', [!Ref 'EnvironmentName', 'VPCId']]

  # Create a rule on the load balancer for routing traffic to the target group
  LoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'TargetGroup'
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values: [!Ref 'Path']
      ListenerArn:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'PublicListener']]
      Priority: !Ref 'Priority'


  CloudWatchLogsGroup:
        Type: AWS::Logs::LogGroup
        Properties: 
            LogGroupName: !Ref AWS::StackName
            RetentionInDays: 365  

  ECSServiceAutoScalingRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    Action:
                    - 'sts:AssumeRole'
                    Effect: Allow
                    Principal:
                        Service:
                        - application-autoscaling.amazonaws.com
            Path: /
            Policies:
            - PolicyName: ecs-service-autoscaling
              PolicyDocument:
                  Statement:
                      Effect: Allow
                      Action:
                      - application-autoscaling:*
                      - cloudwatch:DescribeAlarms
                      - cloudwatch:PutMetricAlarm
                      - ecs:DescribeServices
                      - ecs:UpdateService
                      Resource: "*"           

  ServiceScalableTarget:
        Type: "AWS::ApplicationAutoScaling::ScalableTarget"
        Properties:
            MaxCapacity: !Ref MaxCount
            MinCapacity: !Ref DesiredCount
            ResourceId: !Join
                - /
                - - service
                  - !Ref ClusterName
                  - !GetAtt Service.Name
            RoleARN: !GetAtt  ECSServiceAutoScalingRole.Arn
            ScalableDimension: ecs:service:DesiredCount
            ServiceNamespace: ecs
            
  ServiceScaleOutPolicy:
        Type : "AWS::ApplicationAutoScaling::ScalingPolicy"
        Properties:
            PolicyName: ServiceScaleOutPolicy
            PolicyType: StepScaling
            ScalingTargetId: !Ref ServiceScalableTarget
            StepScalingPolicyConfiguration:
                AdjustmentType: ChangeInCapacity
                Cooldown: 1800
                MetricAggregationType: Average
                StepAdjustments:
                - MetricIntervalLowerBound: 0
                  ScalingAdjustment: 1

  ServiceScaleInPolicy:
        Type : "AWS::ApplicationAutoScaling::ScalingPolicy"
        Properties:
            PolicyName: ServiceScaleInPolicy
            PolicyType: StepScaling
            ScalingTargetId: !Ref ServiceScalableTarget
            StepScalingPolicyConfiguration:
                AdjustmentType: ChangeInCapacity
                Cooldown: 1800
                MetricAggregationType: Average
                StepAdjustments:
                - MetricIntervalUpperBound: 0
                  ScalingAdjustment: -1

  CPUScaleOutAlarm:
        Type: AWS::CloudWatch::Alarm
        Properties:
            AlarmName: CPU utilization greater than 90%
            AlarmDescription: Alarm if cpu utilization greater than 90% of reserved cpu
            Namespace: AWS/ECS
            MetricName: CPUUtilization
            Dimensions:
            - Name: ClusterName
              Value: !Ref ClusterName
            - Name: ServiceName
              Value: !GetAtt Service.Name
            Statistic: Maximum
            Period: '60'
            EvaluationPeriods: '3'
            Threshold: '90'
            ComparisonOperator: GreaterThanThreshold
            AlarmActions:
            - !Ref ServiceScaleOutPolicy

  CPUScaleInAlarm:
        Type: AWS::CloudWatch::Alarm
        Properties:
            AlarmName: CPU utilization less than 30%
            AlarmDescription: Alarm if cpu utilization greater than 30% of reserved cpu
            Namespace: AWS/ECS
            MetricName: CPUUtilization
            Dimensions:
            - Name: ClusterName
              Value: !Ref ClusterName
            - Name: ServiceName
              Value: !GetAtt Service.Name
            Statistic: Maximum
            Period: '60'
            EvaluationPeriods: '10'
            Threshold: '30'
            ComparisonOperator: LessThanThreshold
            AlarmActions:
            - !Ref ServiceScaleInPolicy
  


############# output     #######################
Outputs:
    ServiceUrl: 
        Description: The URL endpoint for the service
        Value: !Join
          - ''
          -  - Fn::ImportValue:
                 !Join [':', [!Ref 'EnvironmentName', 'ExternalUrl']]
             - !Ref HealthCheckPath